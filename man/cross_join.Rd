% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cross_join.R
\name{cross_join}
\alias{cross_join}
\alias{cross_join.tbl_lazy}
\alias{cross_join.data.frame}
\title{Cross Join}
\usage{
cross_join(
  x,
  y,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  na_matches = c("never", "na")
)

\method{cross_join}{tbl_lazy}(
  x,
  y,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  na_matches = c("never", "na")
)

\method{cross_join}{data.frame}(
  x,
  y,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  na_matches = c("na", "never")
)
}
\arguments{
\item{x, y}{A pair of \code{data.frame}s, \code{data.frame} extensions (e.g. a \code{tibble}), or lazy \code{data.frame}s (e.g. from
{dbplyr} or {dtplyr}).}

\item{copy}{\code{logical(1)}. If \code{x} and \code{y} are not from the same data source, and \code{copy} is \code{TRUE}, then \code{y} will be
copied into the same src as \code{x}. This allows you to join tables across srcs, but it is a potentially expensive
operation so you must opt into it.}

\item{suffix}{\code{character(2)}. If there are non-joined duplicate variables in \code{x} and \code{y}, these suffixes will be
added to the output to disambiguate them.}

\item{...}{Other parameters passed onto methods.}

\item{na_matches}{Should \code{NA} and \code{NaN} values match one another?

The default, \code{"na"}, treats two \code{NA} or \code{NaN} values as equal, like \code{\%in\%}, \code{\link[=match]{match()}}, \code{\link[=merge]{merge()}}.

Use \code{"never"} to always treat two \code{NA} or \code{NaN} values as different, like joins for database sources, similarly to
\code{merge(incomparables = FALSE)}.}
}
\description{
The \verb{CROSS JOIN} returns all combinations of \code{x} and \code{y}, i.e. the dataset which is the number of rows in the first
dataset multiplied by the number of rows in the second dataset. This kind of result is called the Cartesian Product.
}
\details{
From Spark 2.1 the prerequisite for using a cross join is that, \code{spark.sql.crossJoin.enabled} must be set to \code{true},
otherwise an exception will be thrown. Cartesian products are very slow. More importantly, they could consume a lot
of memory and trigger an OOM. If the join type is not \code{Inner}, Spark SQL could use a Broadcast Nested Loop Join even
if both sides of tables are not small enough. Thus, it also could cause lots of unwanted network traffic.
}
\examples{
x <- data.frame(
  id = c("id1", "id2", "id3", "id4", "id5"),
  val = c(2, 7, 11, 13, 17),
  stringsAsFactors = FALSE
)
cross_join(x, x)

}
