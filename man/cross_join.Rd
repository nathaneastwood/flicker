% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cross_join.R
\name{cross_join}
\alias{cross_join}
\alias{cross_join.tbl_lazy}
\alias{cross_join.data.frame}
\title{Cross Join}
\usage{
cross_join(
  x,
  y,
  copy = FALSE,
  suffix = c("_x", "_y"),
  ...,
  na_matches = c("never", "na")
)

\method{cross_join}{tbl_lazy}(
  x,
  y,
  copy = FALSE,
  suffix = c("_x", "_y"),
  ...,
  na_matches = c("never", "na")
)

\method{cross_join}{data.frame}(
  x,
  y,
  copy = FALSE,
  suffix = c("_x", "_y"),
  ...,
  na_matches = c("na", "never")
)
}
\arguments{
\item{x, y}{A pair of \code{tbl_spark}s or \code{data.frame}s.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into a
temporary table in same database as \code{x}. \verb{*_join()} will automatically
run \code{ANALYZE} on the created table in the hope that this will make
you queries as efficient as possible by giving more data to the query
planner.

This allows you to join tables across srcs, but it's potentially expensive
operation so you must opt into it.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}

\item{...}{Other parameters passed onto methods.}

\item{na_matches}{Should NA (NULL) values match one another?
The default, "never", is how databases usually work. \code{"na"} makes
the joins behave like the dplyr join functions, \code{\link[=merge]{merge()}}, \code{\link[=match]{match()}},
and \code{\%in\%}.}
}
\description{
The \verb{CROSS JOIN} returns all combinations of \code{x} and \code{y}, i.e. the dataset which is the number of rows in the first
dataset multiplied by the number of rows in the second dataset. This kind of result is called the Cartesian Product.
}
\details{
From Spark 2.1 the prerequisite for using a cross join is that, \code{spark.sql.crossJoin.enabled} must be set to \code{true},
otherwise an exception will be thrown. Cartesian products are very slow. More importantly, they could consume a lot
of memory and trigger an OOM. If the join type is not \code{Inner}, Spark SQL could use a Broadcast Nested Loop Join even
if both sides of tables are not small enough. Thus, it also could cause lots of unwanted network traffic.
}
\examples{
x <- data.frame(
  id = c("id1", "id2", "id3", "id4", "id5"),
  val = c(2, 7, 11, 13, 17),
  stringsAsFactors = FALSE
)
cross_join(x, x)

}
